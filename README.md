# Optimizing Traffic Lights configuration using Genetic Algorithm
## 




## Problem statement 

To develop an algorithm that reduces CO2 emissions in a city by controlling the traffic signals.

## Solution

We will be implementing the genetic algorithm to find the optimal configuration of traffic signals.
Please view the file [Final Presentation](https://github.com/dharma9696/Traffic-Lights-Genetic-Algorithm/blob/main/Project%20Presentation.pptx) for an overview of the project.
Also, go through the [medium post](https://medium.com/@rohit.dharma96/reducing-the-carbon-footprint-by-controlling-traffic-lights-7761758fec1a) for a detailed description of the project.

1. Simulate a road network and populate the network with cars.
2. Connect the simulation to a Python script 
3. Build functions to manipulate the traffic lights in the system.
4. Genetic algorithm to optimize the traffic light configuration.

### Simulation 

- An urban mobility simulation (simple grid network 5x3)
- Sufficient Cars and simulation time
- Traffic lights (Traffic lights can change colors for individual lanes)


Simulations generated using SUMO (Simulation of Urban MObility).
Python script Simulation_Generator.py can be used to create a grid simulation with Traffic lights.

### Connecting Python to the Simulation & Manipulating traffic lights

- Sumolib library is used to launch traffic simulations
- TRACi library is used to control the traffic lights


### Genetic Algorithm

 All GA functions Initalisation, Crossover, Mutation and Selection have been coded without any libraries.

#### Chromosome

- A traffic light has a state (Red, Yellow, Green) and a state duration (10s, 3s, 20s).
- A junction has multiple traffic signals, 4 for a simple intersection.
- A 3 laned road will have 12 (4*3) traffic signals at a junction.
- Our simulation has 3 laned roads and an intersection can have 6, 9 or 12 signals based on its position in the grid.
- A Phase of a signal is the combination of state and state duration. e.g. (R-10, Y-3, G-20) is 1 phase
- In this scenario, all juncations will have 4 phases. After 4 phases, they reset to phase 1.
- __All the phases of a junction are saved in a data class called TLight.__ 



         class TLight(object):
    def __init__(self,ID):
        '''
        Initialize a new data storing object to keep track of the
        emissions and waiting time data over time
        '''

        self.ID = ID
        self.durations = []
        self.states = []


__For our algorithm, a chromosome is a list of all Junctions (TLights) in the simulation.__
    

    Chromosome=[]
    for Junction in TLightIDs:
        states = []
        durations=[]
        TL1 = TLight(Junction)
        states,durations = TL1.get_state_duration(Junction)
        Chromosome.append(TL1) 
        


#### Fitness Function
        
Fitness function is a combination of 3 metrics, and each metric is multiplied by a weight.

- The CO2 emissions in the entire simulation.
- The waiting time for all cars due to the traffic lights.
- A collision penalty, for all cars that collide during the simulation.

#### Crossover and Mutation

Mutation probability and strength of mutation can be changed using parameters

- For crossover, we iterate through all traffic light states and states durations, and randomly select values from the 2 parent chromsomes. Function returns the child chromosome
- Similarly, We mutate the states and state durations by iterating through all states and state durations of a chromosome.

#### Random Initialization

An initial randomized population is needed to have a genetic diversity in the population.
We generate the random population using the mutation function. With a large mutation strength and mutation probability = 1, we are able to generate a randomized population.


#### Combining all the functions

1. Build a randomized initial population
2. Measure the fitness of each inidividual
3. Select the best candidates and crossover their chromosomes to create the child generation
4. Mutate the children to make sure they adapt to the problem statements
5. Continue the same process for the new generation from step 2
6. End the loop after maximum generations are completed

#### Measuring performance and hyperparameter tuning of the System

Using the Weights and Bias library, I am logging the important metrics for each generation.
Charts are generated by the library and hyperparameters for all variables are stored.